Почему? Можно ли обойтись без «подвисания»?
Для начала разберёмся с тем, что тут происходит, а потом подумаем о том, можно ли как-то ускорить эту программу.

Когда мы вызываем функцию — происходит две вещи:

Запускается механизм спискового включения, генерирующий список из примерно 1 миллиарда логических значений, указывающих на то, равно ли каждое из чисел 200 миллионам.
Затем запускается функция any. Она перебирает этот список, проверяя, равен ли какой-нибудь из его элементов значению True. А как только это значение будет обнаружено,
функция возвращает результаты своей работы. Получается, что тут имеется два цикла, в ходе выполнения которых происходит 1,2 миллиарда итераций! Функция any доберётся
до 200-миллионного значения достаточно быстро. А вот списковое включение, с другой стороны, создаёт «тяжёлый» список из 1 миллиарда логических значений. Это занимает
много времени. Когда я запустил эту программу, формирование списка заняло примерно 40 секунд. А функция any нашла в нём первое значение True всего за 2 секунды.
Теперь, когда мы выяснили, что тут происходит — зададимся вопросом о том, можно ли улучшить производительность программы. Главные проблемы здесь — необходимость работы
с огромным количеством значений, и то, что создание списка занимает определённое время. А значит — если мы сократим количество значений, добавляемых в список, это должно
привести к тому, что программа будет работать быстрее.
